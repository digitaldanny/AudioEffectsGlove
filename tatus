[1mdiff --git a/demo/src/main.c b/demo/src/main.c[m
[1mindex bf89658..29706fa 100644[m
[1m--- a/demo/src/main.c[m
[1m+++ b/demo/src/main.c[m
[36m@@ -40,7 +40,7 @@[m
 [m
 // Glove sensor data related[m
 #define FLEX_MIN_ADC    0.0f[m
[31m-#define FLEX_MAX_ADC    170.0f[m
[32m+[m[32m#define FLEX_MAX_ADC    160.0f[m
 [m
 #define FLEX_INDEX_LPF  0[m
 [m
[36m@@ -164,7 +164,7 @@[m [mfloat * currInPtr;[m
 volatile Uint16 adcBResult;[m
 volatile Uint16 adcAResult;[m
 volatile float shift;[m
[31m-volatile float kFilter;[m
[32m+[m[32mvolatile float lpfBinIndexStart;[m
 char wr[6] = "#XX.X"; // store ASCII versions of DFT magnitude in here..[m
 [m
 /*[m
[36m@@ -223,7 +223,7 @@[m [mvoid main(void)[m
     adcB2Init();[m
 [m
     // Enable global Interrupts and higher priority real-time debug events:[m
[31m-    EINT;  // Enable Global interrupt INTM[m
[32m+[m[32m    EINT;  // Enable Global interr222222222222222upt INTM[m
     ERTM;  // Enable Global realtime interrupt DBGM[m
 [m
     // Initialize HC-05 module[m
[36m@@ -359,23 +359,19 @@[m [mvoid main(void)[m
         // adcAResult = AdcaResultRegs.ADCRESULT0; // save results of the conversion[m
         // shift = (MAX_SHIFT - MIN_SHIFT)*(float)adcAResult/(float)4095 + MIN_SHIFT;[m
 [m
[31m-        // // find ADC value to change filter bin by[m
[31m-        // WAIT_FOR_ADC_CONVERSION_B;  // wait for first conversion to complete[m
[31m-        // CLEAR_ADC_FLAG_B;           // clear the interrupt flag generated by the conversion[m
[31m-        // adcBResult = AdcbResultRegs.ADCRESULT0; // save results of the conversion[m
[31m-        // kFilter = (CFFT_SIZE/2-1)*(float)adcBResult/(float)4095;[m
[31m-[m
         // Change LPF starting bin index based on flex sensor 0 reading[m
         // LPF starting index = binMax * (maxFlexVal - measuredFlexVal) / maxFlexVal[m
[31m-        kFilter = FLEX_MAX_ADC - (float)(gloveSensorDataLocal.flexSensors[FLEX_INDEX_LPF]);[m
[31m-        kFilter /= FLEX_MAX_ADC;[m
[31m-        kFilter *= (CFFT_SIZE/2-1);[m
[32m+[m[32m        lpfBinIndexStart = FLEX_MAX_ADC - (float)(gloveSensorDataLocal.flexSensors[FLEX_INDEX_LPF]);[m
[32m+[m[32m        lpfBinIndexStart /= FLEX_MAX_ADC;[m
[32m+[m[32m        lpfBinIndexStart *= (CFFT_SIZE/2-1);[m
[32m+[m[32m        if (lpfBinIndexStart < 0.0f)[m
[32m+[m[32m            lpfBinIndexStart = 0.0f;[m
 [m
         float tens   = abs(shift) / 10.0;[m
         float ones   = (tens - (Uint16)tens) * 10;[m
         float tenths = (ones - (Uint16)ones) * 10;[m
 [m
[31m-        float k_hundreds = abs(kFilter) / 100.0;[m
[32m+[m[32m        float k_hundreds = abs(lpfBinIndexStart) / 100.0;[m
         float k_tens   = (k_hundreds - (Uint16)k_hundreds) * 10;[m
         float k_ones   = (k_tens - (Uint16)k_tens) * 10;[m
 [m
[36m@@ -400,7 +396,7 @@[m [mvoid main(void)[m
              // Create the index for filtering in the buffer[m
              // Uint16 k = 442; // tested value to remove white noise (32KHz sampling) -> 13.8 KHz[m
              // Uint16 k = 295; // (48KHz sampling) -> 13.8 KHz[m
[31m-             Uint16 k = (Uint16)kFilter; // controllable using B2 ADC[m
[32m+[m[32m             Uint16 k = (Uint16)lpfBinIndexStart; // controllable using B2 ADC[m
 [m
              // get rid of the white noise in upper bins[m
              for (Uint16 i = k; i < CFFT_SIZE/2; i++)[m
